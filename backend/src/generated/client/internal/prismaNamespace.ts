
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.js"
import { type PrismaClient } from "./class.js"

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.0.1
 * Query Engine version: f09f2815f091dbba658cdcd2264306d88bb5bda6
 */
export const prismaVersion: PrismaVersion = {
  client: "7.0.1",
  engine: "f09f2815f091dbba658cdcd2264306d88bb5bda6"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  agreement_rate_cards: 'agreement_rate_cards',
  audit_logs: 'audit_logs',
  business_units: 'business_units',
  cab_agreements: 'cab_agreements',
  cab_services: 'cab_services',
  departments: 'departments',
  documents: 'documents',
  drivers: 'drivers',
  email_templates: 'email_templates',
  emergency_contacts: 'emergency_contacts',
  expiry_alerts: 'expiry_alerts',
  geofences: 'geofences',
  gps_devices: 'gps_devices',
  gps_logs: 'gps_logs',
  holidays: 'holidays',
  insurance_policies: 'insurance_policies',
  login_history: 'login_history',
  maintenance_logs: 'maintenance_logs',
  maintenance_parts: 'maintenance_parts',
  notifications: 'notifications',
  permissions: 'permissions',
  role_permissions: 'role_permissions',
  roles: 'roles',
  RefreshToken: 'RefreshToken',
  system_alerts: 'system_alerts',
  system_settings: 'system_settings',
  trip_approvals: 'trip_approvals',
  trip_assignments: 'trip_assignments',
  trip_costs: 'trip_costs',
  trip_logs: 'trip_logs',
  trip_passengers: 'trip_passengers',
  trip_requests: 'trip_requests',
  user_roles: 'user_roles',
  users: 'users',
  vehicle_leases: 'vehicle_leases',
  vehicles: 'vehicles',
  rate_limit: 'rate_limit',
  PasswordReset: 'PasswordReset'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "agreement_rate_cards" | "audit_logs" | "business_units" | "cab_agreements" | "cab_services" | "departments" | "documents" | "drivers" | "email_templates" | "emergency_contacts" | "expiry_alerts" | "geofences" | "gps_devices" | "gps_logs" | "holidays" | "insurance_policies" | "login_history" | "maintenance_logs" | "maintenance_parts" | "notifications" | "permissions" | "role_permissions" | "roles" | "refreshToken" | "system_alerts" | "system_settings" | "trip_approvals" | "trip_assignments" | "trip_costs" | "trip_logs" | "trip_passengers" | "trip_requests" | "user_roles" | "users" | "vehicle_leases" | "vehicles" | "rate_limit" | "passwordReset"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    agreement_rate_cards: {
      payload: Prisma.$agreement_rate_cardsPayload<ExtArgs>
      fields: Prisma.agreement_rate_cardsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.agreement_rate_cardsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.agreement_rate_cardsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload>
        }
        findFirst: {
          args: Prisma.agreement_rate_cardsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.agreement_rate_cardsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload>
        }
        findMany: {
          args: Prisma.agreement_rate_cardsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload>[]
        }
        create: {
          args: Prisma.agreement_rate_cardsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload>
        }
        createMany: {
          args: Prisma.agreement_rate_cardsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.agreement_rate_cardsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload>[]
        }
        delete: {
          args: Prisma.agreement_rate_cardsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload>
        }
        update: {
          args: Prisma.agreement_rate_cardsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload>
        }
        deleteMany: {
          args: Prisma.agreement_rate_cardsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.agreement_rate_cardsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.agreement_rate_cardsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload>[]
        }
        upsert: {
          args: Prisma.agreement_rate_cardsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$agreement_rate_cardsPayload>
        }
        aggregate: {
          args: Prisma.Agreement_rate_cardsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAgreement_rate_cards>
        }
        groupBy: {
          args: Prisma.agreement_rate_cardsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Agreement_rate_cardsGroupByOutputType>[]
        }
        count: {
          args: Prisma.agreement_rate_cardsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Agreement_rate_cardsCountAggregateOutputType> | number
        }
      }
    }
    audit_logs: {
      payload: Prisma.$audit_logsPayload<ExtArgs>
      fields: Prisma.audit_logsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.audit_logsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.audit_logsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload>
        }
        findFirst: {
          args: Prisma.audit_logsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.audit_logsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload>
        }
        findMany: {
          args: Prisma.audit_logsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
        }
        create: {
          args: Prisma.audit_logsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload>
        }
        createMany: {
          args: Prisma.audit_logsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.audit_logsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
        }
        delete: {
          args: Prisma.audit_logsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload>
        }
        update: {
          args: Prisma.audit_logsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload>
        }
        deleteMany: {
          args: Prisma.audit_logsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.audit_logsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.audit_logsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
        }
        upsert: {
          args: Prisma.audit_logsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$audit_logsPayload>
        }
        aggregate: {
          args: Prisma.Audit_logsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAudit_logs>
        }
        groupBy: {
          args: Prisma.audit_logsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Audit_logsGroupByOutputType>[]
        }
        count: {
          args: Prisma.audit_logsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Audit_logsCountAggregateOutputType> | number
        }
      }
    }
    business_units: {
      payload: Prisma.$business_unitsPayload<ExtArgs>
      fields: Prisma.business_unitsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.business_unitsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.business_unitsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload>
        }
        findFirst: {
          args: Prisma.business_unitsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.business_unitsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload>
        }
        findMany: {
          args: Prisma.business_unitsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload>[]
        }
        create: {
          args: Prisma.business_unitsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload>
        }
        createMany: {
          args: Prisma.business_unitsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.business_unitsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload>[]
        }
        delete: {
          args: Prisma.business_unitsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload>
        }
        update: {
          args: Prisma.business_unitsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload>
        }
        deleteMany: {
          args: Prisma.business_unitsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.business_unitsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.business_unitsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload>[]
        }
        upsert: {
          args: Prisma.business_unitsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$business_unitsPayload>
        }
        aggregate: {
          args: Prisma.Business_unitsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBusiness_units>
        }
        groupBy: {
          args: Prisma.business_unitsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Business_unitsGroupByOutputType>[]
        }
        count: {
          args: Prisma.business_unitsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Business_unitsCountAggregateOutputType> | number
        }
      }
    }
    cab_agreements: {
      payload: Prisma.$cab_agreementsPayload<ExtArgs>
      fields: Prisma.cab_agreementsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.cab_agreementsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.cab_agreementsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload>
        }
        findFirst: {
          args: Prisma.cab_agreementsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.cab_agreementsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload>
        }
        findMany: {
          args: Prisma.cab_agreementsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload>[]
        }
        create: {
          args: Prisma.cab_agreementsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload>
        }
        createMany: {
          args: Prisma.cab_agreementsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.cab_agreementsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload>[]
        }
        delete: {
          args: Prisma.cab_agreementsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload>
        }
        update: {
          args: Prisma.cab_agreementsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload>
        }
        deleteMany: {
          args: Prisma.cab_agreementsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.cab_agreementsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.cab_agreementsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload>[]
        }
        upsert: {
          args: Prisma.cab_agreementsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_agreementsPayload>
        }
        aggregate: {
          args: Prisma.Cab_agreementsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCab_agreements>
        }
        groupBy: {
          args: Prisma.cab_agreementsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Cab_agreementsGroupByOutputType>[]
        }
        count: {
          args: Prisma.cab_agreementsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Cab_agreementsCountAggregateOutputType> | number
        }
      }
    }
    cab_services: {
      payload: Prisma.$cab_servicesPayload<ExtArgs>
      fields: Prisma.cab_servicesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.cab_servicesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.cab_servicesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload>
        }
        findFirst: {
          args: Prisma.cab_servicesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.cab_servicesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload>
        }
        findMany: {
          args: Prisma.cab_servicesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload>[]
        }
        create: {
          args: Prisma.cab_servicesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload>
        }
        createMany: {
          args: Prisma.cab_servicesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.cab_servicesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload>[]
        }
        delete: {
          args: Prisma.cab_servicesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload>
        }
        update: {
          args: Prisma.cab_servicesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload>
        }
        deleteMany: {
          args: Prisma.cab_servicesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.cab_servicesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.cab_servicesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload>[]
        }
        upsert: {
          args: Prisma.cab_servicesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$cab_servicesPayload>
        }
        aggregate: {
          args: Prisma.Cab_servicesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCab_services>
        }
        groupBy: {
          args: Prisma.cab_servicesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Cab_servicesGroupByOutputType>[]
        }
        count: {
          args: Prisma.cab_servicesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Cab_servicesCountAggregateOutputType> | number
        }
      }
    }
    departments: {
      payload: Prisma.$departmentsPayload<ExtArgs>
      fields: Prisma.departmentsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.departmentsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.departmentsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload>
        }
        findFirst: {
          args: Prisma.departmentsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.departmentsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload>
        }
        findMany: {
          args: Prisma.departmentsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload>[]
        }
        create: {
          args: Prisma.departmentsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload>
        }
        createMany: {
          args: Prisma.departmentsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.departmentsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload>[]
        }
        delete: {
          args: Prisma.departmentsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload>
        }
        update: {
          args: Prisma.departmentsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload>
        }
        deleteMany: {
          args: Prisma.departmentsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.departmentsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.departmentsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload>[]
        }
        upsert: {
          args: Prisma.departmentsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$departmentsPayload>
        }
        aggregate: {
          args: Prisma.DepartmentsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDepartments>
        }
        groupBy: {
          args: Prisma.departmentsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentsGroupByOutputType>[]
        }
        count: {
          args: Prisma.departmentsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentsCountAggregateOutputType> | number
        }
      }
    }
    documents: {
      payload: Prisma.$documentsPayload<ExtArgs>
      fields: Prisma.documentsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.documentsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.documentsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload>
        }
        findFirst: {
          args: Prisma.documentsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.documentsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload>
        }
        findMany: {
          args: Prisma.documentsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload>[]
        }
        create: {
          args: Prisma.documentsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload>
        }
        createMany: {
          args: Prisma.documentsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.documentsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload>[]
        }
        delete: {
          args: Prisma.documentsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload>
        }
        update: {
          args: Prisma.documentsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload>
        }
        deleteMany: {
          args: Prisma.documentsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.documentsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.documentsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload>[]
        }
        upsert: {
          args: Prisma.documentsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$documentsPayload>
        }
        aggregate: {
          args: Prisma.DocumentsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocuments>
        }
        groupBy: {
          args: Prisma.documentsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentsGroupByOutputType>[]
        }
        count: {
          args: Prisma.documentsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentsCountAggregateOutputType> | number
        }
      }
    }
    drivers: {
      payload: Prisma.$driversPayload<ExtArgs>
      fields: Prisma.driversFieldRefs
      operations: {
        findUnique: {
          args: Prisma.driversFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.driversFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload>
        }
        findFirst: {
          args: Prisma.driversFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.driversFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload>
        }
        findMany: {
          args: Prisma.driversFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload>[]
        }
        create: {
          args: Prisma.driversCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload>
        }
        createMany: {
          args: Prisma.driversCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.driversCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload>[]
        }
        delete: {
          args: Prisma.driversDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload>
        }
        update: {
          args: Prisma.driversUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload>
        }
        deleteMany: {
          args: Prisma.driversDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.driversUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.driversUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload>[]
        }
        upsert: {
          args: Prisma.driversUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$driversPayload>
        }
        aggregate: {
          args: Prisma.DriversAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDrivers>
        }
        groupBy: {
          args: Prisma.driversGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DriversGroupByOutputType>[]
        }
        count: {
          args: Prisma.driversCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DriversCountAggregateOutputType> | number
        }
      }
    }
    email_templates: {
      payload: Prisma.$email_templatesPayload<ExtArgs>
      fields: Prisma.email_templatesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.email_templatesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.email_templatesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload>
        }
        findFirst: {
          args: Prisma.email_templatesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.email_templatesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload>
        }
        findMany: {
          args: Prisma.email_templatesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
        }
        create: {
          args: Prisma.email_templatesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload>
        }
        createMany: {
          args: Prisma.email_templatesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.email_templatesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
        }
        delete: {
          args: Prisma.email_templatesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload>
        }
        update: {
          args: Prisma.email_templatesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload>
        }
        deleteMany: {
          args: Prisma.email_templatesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.email_templatesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.email_templatesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
        }
        upsert: {
          args: Prisma.email_templatesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$email_templatesPayload>
        }
        aggregate: {
          args: Prisma.Email_templatesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmail_templates>
        }
        groupBy: {
          args: Prisma.email_templatesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Email_templatesGroupByOutputType>[]
        }
        count: {
          args: Prisma.email_templatesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Email_templatesCountAggregateOutputType> | number
        }
      }
    }
    emergency_contacts: {
      payload: Prisma.$emergency_contactsPayload<ExtArgs>
      fields: Prisma.emergency_contactsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.emergency_contactsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.emergency_contactsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload>
        }
        findFirst: {
          args: Prisma.emergency_contactsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.emergency_contactsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload>
        }
        findMany: {
          args: Prisma.emergency_contactsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload>[]
        }
        create: {
          args: Prisma.emergency_contactsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload>
        }
        createMany: {
          args: Prisma.emergency_contactsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.emergency_contactsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload>[]
        }
        delete: {
          args: Prisma.emergency_contactsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload>
        }
        update: {
          args: Prisma.emergency_contactsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload>
        }
        deleteMany: {
          args: Prisma.emergency_contactsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.emergency_contactsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.emergency_contactsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload>[]
        }
        upsert: {
          args: Prisma.emergency_contactsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$emergency_contactsPayload>
        }
        aggregate: {
          args: Prisma.Emergency_contactsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmergency_contacts>
        }
        groupBy: {
          args: Prisma.emergency_contactsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Emergency_contactsGroupByOutputType>[]
        }
        count: {
          args: Prisma.emergency_contactsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Emergency_contactsCountAggregateOutputType> | number
        }
      }
    }
    expiry_alerts: {
      payload: Prisma.$expiry_alertsPayload<ExtArgs>
      fields: Prisma.expiry_alertsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.expiry_alertsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.expiry_alertsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload>
        }
        findFirst: {
          args: Prisma.expiry_alertsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.expiry_alertsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload>
        }
        findMany: {
          args: Prisma.expiry_alertsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload>[]
        }
        create: {
          args: Prisma.expiry_alertsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload>
        }
        createMany: {
          args: Prisma.expiry_alertsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.expiry_alertsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload>[]
        }
        delete: {
          args: Prisma.expiry_alertsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload>
        }
        update: {
          args: Prisma.expiry_alertsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload>
        }
        deleteMany: {
          args: Prisma.expiry_alertsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.expiry_alertsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.expiry_alertsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload>[]
        }
        upsert: {
          args: Prisma.expiry_alertsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$expiry_alertsPayload>
        }
        aggregate: {
          args: Prisma.Expiry_alertsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpiry_alerts>
        }
        groupBy: {
          args: Prisma.expiry_alertsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Expiry_alertsGroupByOutputType>[]
        }
        count: {
          args: Prisma.expiry_alertsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Expiry_alertsCountAggregateOutputType> | number
        }
      }
    }
    geofences: {
      payload: Prisma.$geofencesPayload<ExtArgs>
      fields: Prisma.geofencesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.geofencesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.geofencesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload>
        }
        findFirst: {
          args: Prisma.geofencesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.geofencesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload>
        }
        findMany: {
          args: Prisma.geofencesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload>[]
        }
        create: {
          args: Prisma.geofencesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload>
        }
        createMany: {
          args: Prisma.geofencesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.geofencesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload>[]
        }
        delete: {
          args: Prisma.geofencesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload>
        }
        update: {
          args: Prisma.geofencesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload>
        }
        deleteMany: {
          args: Prisma.geofencesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.geofencesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.geofencesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload>[]
        }
        upsert: {
          args: Prisma.geofencesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$geofencesPayload>
        }
        aggregate: {
          args: Prisma.GeofencesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGeofences>
        }
        groupBy: {
          args: Prisma.geofencesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GeofencesGroupByOutputType>[]
        }
        count: {
          args: Prisma.geofencesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GeofencesCountAggregateOutputType> | number
        }
      }
    }
    gps_devices: {
      payload: Prisma.$gps_devicesPayload<ExtArgs>
      fields: Prisma.gps_devicesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.gps_devicesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.gps_devicesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload>
        }
        findFirst: {
          args: Prisma.gps_devicesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.gps_devicesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload>
        }
        findMany: {
          args: Prisma.gps_devicesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload>[]
        }
        create: {
          args: Prisma.gps_devicesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload>
        }
        createMany: {
          args: Prisma.gps_devicesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.gps_devicesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload>[]
        }
        delete: {
          args: Prisma.gps_devicesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload>
        }
        update: {
          args: Prisma.gps_devicesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload>
        }
        deleteMany: {
          args: Prisma.gps_devicesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.gps_devicesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.gps_devicesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload>[]
        }
        upsert: {
          args: Prisma.gps_devicesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_devicesPayload>
        }
        aggregate: {
          args: Prisma.Gps_devicesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGps_devices>
        }
        groupBy: {
          args: Prisma.gps_devicesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Gps_devicesGroupByOutputType>[]
        }
        count: {
          args: Prisma.gps_devicesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Gps_devicesCountAggregateOutputType> | number
        }
      }
    }
    gps_logs: {
      payload: Prisma.$gps_logsPayload<ExtArgs>
      fields: Prisma.gps_logsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.gps_logsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.gps_logsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload>
        }
        findFirst: {
          args: Prisma.gps_logsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.gps_logsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload>
        }
        findMany: {
          args: Prisma.gps_logsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload>[]
        }
        create: {
          args: Prisma.gps_logsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload>
        }
        createMany: {
          args: Prisma.gps_logsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.gps_logsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload>[]
        }
        delete: {
          args: Prisma.gps_logsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload>
        }
        update: {
          args: Prisma.gps_logsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload>
        }
        deleteMany: {
          args: Prisma.gps_logsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.gps_logsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.gps_logsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload>[]
        }
        upsert: {
          args: Prisma.gps_logsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$gps_logsPayload>
        }
        aggregate: {
          args: Prisma.Gps_logsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGps_logs>
        }
        groupBy: {
          args: Prisma.gps_logsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Gps_logsGroupByOutputType>[]
        }
        count: {
          args: Prisma.gps_logsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Gps_logsCountAggregateOutputType> | number
        }
      }
    }
    holidays: {
      payload: Prisma.$holidaysPayload<ExtArgs>
      fields: Prisma.holidaysFieldRefs
      operations: {
        findUnique: {
          args: Prisma.holidaysFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.holidaysFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload>
        }
        findFirst: {
          args: Prisma.holidaysFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.holidaysFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload>
        }
        findMany: {
          args: Prisma.holidaysFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload>[]
        }
        create: {
          args: Prisma.holidaysCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload>
        }
        createMany: {
          args: Prisma.holidaysCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.holidaysCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload>[]
        }
        delete: {
          args: Prisma.holidaysDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload>
        }
        update: {
          args: Prisma.holidaysUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload>
        }
        deleteMany: {
          args: Prisma.holidaysDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.holidaysUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.holidaysUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload>[]
        }
        upsert: {
          args: Prisma.holidaysUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$holidaysPayload>
        }
        aggregate: {
          args: Prisma.HolidaysAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHolidays>
        }
        groupBy: {
          args: Prisma.holidaysGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HolidaysGroupByOutputType>[]
        }
        count: {
          args: Prisma.holidaysCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HolidaysCountAggregateOutputType> | number
        }
      }
    }
    insurance_policies: {
      payload: Prisma.$insurance_policiesPayload<ExtArgs>
      fields: Prisma.insurance_policiesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.insurance_policiesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.insurance_policiesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload>
        }
        findFirst: {
          args: Prisma.insurance_policiesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.insurance_policiesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload>
        }
        findMany: {
          args: Prisma.insurance_policiesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload>[]
        }
        create: {
          args: Prisma.insurance_policiesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload>
        }
        createMany: {
          args: Prisma.insurance_policiesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.insurance_policiesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload>[]
        }
        delete: {
          args: Prisma.insurance_policiesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload>
        }
        update: {
          args: Prisma.insurance_policiesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload>
        }
        deleteMany: {
          args: Prisma.insurance_policiesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.insurance_policiesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.insurance_policiesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload>[]
        }
        upsert: {
          args: Prisma.insurance_policiesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$insurance_policiesPayload>
        }
        aggregate: {
          args: Prisma.Insurance_policiesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInsurance_policies>
        }
        groupBy: {
          args: Prisma.insurance_policiesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Insurance_policiesGroupByOutputType>[]
        }
        count: {
          args: Prisma.insurance_policiesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Insurance_policiesCountAggregateOutputType> | number
        }
      }
    }
    login_history: {
      payload: Prisma.$login_historyPayload<ExtArgs>
      fields: Prisma.login_historyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.login_historyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.login_historyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload>
        }
        findFirst: {
          args: Prisma.login_historyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.login_historyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload>
        }
        findMany: {
          args: Prisma.login_historyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload>[]
        }
        create: {
          args: Prisma.login_historyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload>
        }
        createMany: {
          args: Prisma.login_historyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.login_historyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload>[]
        }
        delete: {
          args: Prisma.login_historyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload>
        }
        update: {
          args: Prisma.login_historyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload>
        }
        deleteMany: {
          args: Prisma.login_historyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.login_historyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.login_historyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload>[]
        }
        upsert: {
          args: Prisma.login_historyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$login_historyPayload>
        }
        aggregate: {
          args: Prisma.Login_historyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLogin_history>
        }
        groupBy: {
          args: Prisma.login_historyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Login_historyGroupByOutputType>[]
        }
        count: {
          args: Prisma.login_historyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Login_historyCountAggregateOutputType> | number
        }
      }
    }
    maintenance_logs: {
      payload: Prisma.$maintenance_logsPayload<ExtArgs>
      fields: Prisma.maintenance_logsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.maintenance_logsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.maintenance_logsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload>
        }
        findFirst: {
          args: Prisma.maintenance_logsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.maintenance_logsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload>
        }
        findMany: {
          args: Prisma.maintenance_logsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload>[]
        }
        create: {
          args: Prisma.maintenance_logsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload>
        }
        createMany: {
          args: Prisma.maintenance_logsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.maintenance_logsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload>[]
        }
        delete: {
          args: Prisma.maintenance_logsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload>
        }
        update: {
          args: Prisma.maintenance_logsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload>
        }
        deleteMany: {
          args: Prisma.maintenance_logsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.maintenance_logsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.maintenance_logsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload>[]
        }
        upsert: {
          args: Prisma.maintenance_logsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_logsPayload>
        }
        aggregate: {
          args: Prisma.Maintenance_logsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMaintenance_logs>
        }
        groupBy: {
          args: Prisma.maintenance_logsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Maintenance_logsGroupByOutputType>[]
        }
        count: {
          args: Prisma.maintenance_logsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Maintenance_logsCountAggregateOutputType> | number
        }
      }
    }
    maintenance_parts: {
      payload: Prisma.$maintenance_partsPayload<ExtArgs>
      fields: Prisma.maintenance_partsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.maintenance_partsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.maintenance_partsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload>
        }
        findFirst: {
          args: Prisma.maintenance_partsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.maintenance_partsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload>
        }
        findMany: {
          args: Prisma.maintenance_partsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload>[]
        }
        create: {
          args: Prisma.maintenance_partsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload>
        }
        createMany: {
          args: Prisma.maintenance_partsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.maintenance_partsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload>[]
        }
        delete: {
          args: Prisma.maintenance_partsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload>
        }
        update: {
          args: Prisma.maintenance_partsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload>
        }
        deleteMany: {
          args: Prisma.maintenance_partsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.maintenance_partsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.maintenance_partsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload>[]
        }
        upsert: {
          args: Prisma.maintenance_partsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_partsPayload>
        }
        aggregate: {
          args: Prisma.Maintenance_partsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMaintenance_parts>
        }
        groupBy: {
          args: Prisma.maintenance_partsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Maintenance_partsGroupByOutputType>[]
        }
        count: {
          args: Prisma.maintenance_partsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Maintenance_partsCountAggregateOutputType> | number
        }
      }
    }
    notifications: {
      payload: Prisma.$notificationsPayload<ExtArgs>
      fields: Prisma.notificationsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.notificationsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload>
        }
        findFirst: {
          args: Prisma.notificationsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload>
        }
        findMany: {
          args: Prisma.notificationsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload>[]
        }
        create: {
          args: Prisma.notificationsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload>
        }
        createMany: {
          args: Prisma.notificationsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload>[]
        }
        delete: {
          args: Prisma.notificationsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload>
        }
        update: {
          args: Prisma.notificationsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload>
        }
        deleteMany: {
          args: Prisma.notificationsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.notificationsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.notificationsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload>[]
        }
        upsert: {
          args: Prisma.notificationsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$notificationsPayload>
        }
        aggregate: {
          args: Prisma.NotificationsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotifications>
        }
        groupBy: {
          args: Prisma.notificationsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationsGroupByOutputType>[]
        }
        count: {
          args: Prisma.notificationsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationsCountAggregateOutputType> | number
        }
      }
    }
    permissions: {
      payload: Prisma.$permissionsPayload<ExtArgs>
      fields: Prisma.permissionsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.permissionsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.permissionsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload>
        }
        findFirst: {
          args: Prisma.permissionsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.permissionsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload>
        }
        findMany: {
          args: Prisma.permissionsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload>[]
        }
        create: {
          args: Prisma.permissionsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload>
        }
        createMany: {
          args: Prisma.permissionsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.permissionsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload>[]
        }
        delete: {
          args: Prisma.permissionsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload>
        }
        update: {
          args: Prisma.permissionsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload>
        }
        deleteMany: {
          args: Prisma.permissionsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.permissionsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.permissionsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload>[]
        }
        upsert: {
          args: Prisma.permissionsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permissionsPayload>
        }
        aggregate: {
          args: Prisma.PermissionsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermissions>
        }
        groupBy: {
          args: Prisma.permissionsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionsGroupByOutputType>[]
        }
        count: {
          args: Prisma.permissionsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionsCountAggregateOutputType> | number
        }
      }
    }
    role_permissions: {
      payload: Prisma.$role_permissionsPayload<ExtArgs>
      fields: Prisma.role_permissionsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.role_permissionsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.role_permissionsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload>
        }
        findFirst: {
          args: Prisma.role_permissionsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.role_permissionsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload>
        }
        findMany: {
          args: Prisma.role_permissionsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload>[]
        }
        create: {
          args: Prisma.role_permissionsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload>
        }
        createMany: {
          args: Prisma.role_permissionsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.role_permissionsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload>[]
        }
        delete: {
          args: Prisma.role_permissionsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload>
        }
        update: {
          args: Prisma.role_permissionsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload>
        }
        deleteMany: {
          args: Prisma.role_permissionsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.role_permissionsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.role_permissionsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload>[]
        }
        upsert: {
          args: Prisma.role_permissionsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionsPayload>
        }
        aggregate: {
          args: Prisma.Role_permissionsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole_permissions>
        }
        groupBy: {
          args: Prisma.role_permissionsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Role_permissionsGroupByOutputType>[]
        }
        count: {
          args: Prisma.role_permissionsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Role_permissionsCountAggregateOutputType> | number
        }
      }
    }
    roles: {
      payload: Prisma.$rolesPayload<ExtArgs>
      fields: Prisma.rolesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.rolesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload>
        }
        findFirst: {
          args: Prisma.rolesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload>
        }
        findMany: {
          args: Prisma.rolesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload>[]
        }
        create: {
          args: Prisma.rolesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload>
        }
        createMany: {
          args: Prisma.rolesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.rolesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload>[]
        }
        delete: {
          args: Prisma.rolesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload>
        }
        update: {
          args: Prisma.rolesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload>
        }
        deleteMany: {
          args: Prisma.rolesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.rolesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.rolesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload>[]
        }
        upsert: {
          args: Prisma.rolesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolesPayload>
        }
        aggregate: {
          args: Prisma.RolesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRoles>
        }
        groupBy: {
          args: Prisma.rolesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolesGroupByOutputType>[]
        }
        count: {
          args: Prisma.rolesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolesCountAggregateOutputType> | number
        }
      }
    }
    RefreshToken: {
      payload: Prisma.$RefreshTokenPayload<ExtArgs>
      fields: Prisma.RefreshTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        findFirst: {
          args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        findMany: {
          args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
        }
        create: {
          args: Prisma.RefreshTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        createMany: {
          args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
        }
        delete: {
          args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        update: {
          args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        deleteMany: {
          args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
        }
        upsert: {
          args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        aggregate: {
          args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRefreshToken>
        }
        groupBy: {
          args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefreshTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.RefreshTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefreshTokenCountAggregateOutputType> | number
        }
      }
    }
    system_alerts: {
      payload: Prisma.$system_alertsPayload<ExtArgs>
      fields: Prisma.system_alertsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.system_alertsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.system_alertsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload>
        }
        findFirst: {
          args: Prisma.system_alertsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.system_alertsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload>
        }
        findMany: {
          args: Prisma.system_alertsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload>[]
        }
        create: {
          args: Prisma.system_alertsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload>
        }
        createMany: {
          args: Prisma.system_alertsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.system_alertsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload>[]
        }
        delete: {
          args: Prisma.system_alertsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload>
        }
        update: {
          args: Prisma.system_alertsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload>
        }
        deleteMany: {
          args: Prisma.system_alertsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.system_alertsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.system_alertsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload>[]
        }
        upsert: {
          args: Prisma.system_alertsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_alertsPayload>
        }
        aggregate: {
          args: Prisma.System_alertsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSystem_alerts>
        }
        groupBy: {
          args: Prisma.system_alertsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.System_alertsGroupByOutputType>[]
        }
        count: {
          args: Prisma.system_alertsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.System_alertsCountAggregateOutputType> | number
        }
      }
    }
    system_settings: {
      payload: Prisma.$system_settingsPayload<ExtArgs>
      fields: Prisma.system_settingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.system_settingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.system_settingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload>
        }
        findFirst: {
          args: Prisma.system_settingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.system_settingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload>
        }
        findMany: {
          args: Prisma.system_settingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload>[]
        }
        create: {
          args: Prisma.system_settingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload>
        }
        createMany: {
          args: Prisma.system_settingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.system_settingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload>[]
        }
        delete: {
          args: Prisma.system_settingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload>
        }
        update: {
          args: Prisma.system_settingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload>
        }
        deleteMany: {
          args: Prisma.system_settingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.system_settingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.system_settingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload>[]
        }
        upsert: {
          args: Prisma.system_settingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$system_settingsPayload>
        }
        aggregate: {
          args: Prisma.System_settingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSystem_settings>
        }
        groupBy: {
          args: Prisma.system_settingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.System_settingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.system_settingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.System_settingsCountAggregateOutputType> | number
        }
      }
    }
    trip_approvals: {
      payload: Prisma.$trip_approvalsPayload<ExtArgs>
      fields: Prisma.trip_approvalsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.trip_approvalsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.trip_approvalsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload>
        }
        findFirst: {
          args: Prisma.trip_approvalsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.trip_approvalsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload>
        }
        findMany: {
          args: Prisma.trip_approvalsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload>[]
        }
        create: {
          args: Prisma.trip_approvalsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload>
        }
        createMany: {
          args: Prisma.trip_approvalsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.trip_approvalsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload>[]
        }
        delete: {
          args: Prisma.trip_approvalsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload>
        }
        update: {
          args: Prisma.trip_approvalsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload>
        }
        deleteMany: {
          args: Prisma.trip_approvalsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.trip_approvalsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.trip_approvalsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload>[]
        }
        upsert: {
          args: Prisma.trip_approvalsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_approvalsPayload>
        }
        aggregate: {
          args: Prisma.Trip_approvalsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrip_approvals>
        }
        groupBy: {
          args: Prisma.trip_approvalsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_approvalsGroupByOutputType>[]
        }
        count: {
          args: Prisma.trip_approvalsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_approvalsCountAggregateOutputType> | number
        }
      }
    }
    trip_assignments: {
      payload: Prisma.$trip_assignmentsPayload<ExtArgs>
      fields: Prisma.trip_assignmentsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.trip_assignmentsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.trip_assignmentsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload>
        }
        findFirst: {
          args: Prisma.trip_assignmentsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.trip_assignmentsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload>
        }
        findMany: {
          args: Prisma.trip_assignmentsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload>[]
        }
        create: {
          args: Prisma.trip_assignmentsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload>
        }
        createMany: {
          args: Prisma.trip_assignmentsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.trip_assignmentsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload>[]
        }
        delete: {
          args: Prisma.trip_assignmentsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload>
        }
        update: {
          args: Prisma.trip_assignmentsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload>
        }
        deleteMany: {
          args: Prisma.trip_assignmentsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.trip_assignmentsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.trip_assignmentsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload>[]
        }
        upsert: {
          args: Prisma.trip_assignmentsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_assignmentsPayload>
        }
        aggregate: {
          args: Prisma.Trip_assignmentsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrip_assignments>
        }
        groupBy: {
          args: Prisma.trip_assignmentsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_assignmentsGroupByOutputType>[]
        }
        count: {
          args: Prisma.trip_assignmentsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_assignmentsCountAggregateOutputType> | number
        }
      }
    }
    trip_costs: {
      payload: Prisma.$trip_costsPayload<ExtArgs>
      fields: Prisma.trip_costsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.trip_costsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.trip_costsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload>
        }
        findFirst: {
          args: Prisma.trip_costsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.trip_costsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload>
        }
        findMany: {
          args: Prisma.trip_costsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload>[]
        }
        create: {
          args: Prisma.trip_costsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload>
        }
        createMany: {
          args: Prisma.trip_costsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.trip_costsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload>[]
        }
        delete: {
          args: Prisma.trip_costsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload>
        }
        update: {
          args: Prisma.trip_costsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload>
        }
        deleteMany: {
          args: Prisma.trip_costsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.trip_costsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.trip_costsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload>[]
        }
        upsert: {
          args: Prisma.trip_costsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_costsPayload>
        }
        aggregate: {
          args: Prisma.Trip_costsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrip_costs>
        }
        groupBy: {
          args: Prisma.trip_costsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_costsGroupByOutputType>[]
        }
        count: {
          args: Prisma.trip_costsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_costsCountAggregateOutputType> | number
        }
      }
    }
    trip_logs: {
      payload: Prisma.$trip_logsPayload<ExtArgs>
      fields: Prisma.trip_logsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.trip_logsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.trip_logsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload>
        }
        findFirst: {
          args: Prisma.trip_logsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.trip_logsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload>
        }
        findMany: {
          args: Prisma.trip_logsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload>[]
        }
        create: {
          args: Prisma.trip_logsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload>
        }
        createMany: {
          args: Prisma.trip_logsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.trip_logsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload>[]
        }
        delete: {
          args: Prisma.trip_logsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload>
        }
        update: {
          args: Prisma.trip_logsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload>
        }
        deleteMany: {
          args: Prisma.trip_logsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.trip_logsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.trip_logsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload>[]
        }
        upsert: {
          args: Prisma.trip_logsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_logsPayload>
        }
        aggregate: {
          args: Prisma.Trip_logsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrip_logs>
        }
        groupBy: {
          args: Prisma.trip_logsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_logsGroupByOutputType>[]
        }
        count: {
          args: Prisma.trip_logsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_logsCountAggregateOutputType> | number
        }
      }
    }
    trip_passengers: {
      payload: Prisma.$trip_passengersPayload<ExtArgs>
      fields: Prisma.trip_passengersFieldRefs
      operations: {
        findUnique: {
          args: Prisma.trip_passengersFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.trip_passengersFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload>
        }
        findFirst: {
          args: Prisma.trip_passengersFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.trip_passengersFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload>
        }
        findMany: {
          args: Prisma.trip_passengersFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload>[]
        }
        create: {
          args: Prisma.trip_passengersCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload>
        }
        createMany: {
          args: Prisma.trip_passengersCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.trip_passengersCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload>[]
        }
        delete: {
          args: Prisma.trip_passengersDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload>
        }
        update: {
          args: Prisma.trip_passengersUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload>
        }
        deleteMany: {
          args: Prisma.trip_passengersDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.trip_passengersUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.trip_passengersUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload>[]
        }
        upsert: {
          args: Prisma.trip_passengersUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_passengersPayload>
        }
        aggregate: {
          args: Prisma.Trip_passengersAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrip_passengers>
        }
        groupBy: {
          args: Prisma.trip_passengersGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_passengersGroupByOutputType>[]
        }
        count: {
          args: Prisma.trip_passengersCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_passengersCountAggregateOutputType> | number
        }
      }
    }
    trip_requests: {
      payload: Prisma.$trip_requestsPayload<ExtArgs>
      fields: Prisma.trip_requestsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.trip_requestsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.trip_requestsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload>
        }
        findFirst: {
          args: Prisma.trip_requestsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.trip_requestsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload>
        }
        findMany: {
          args: Prisma.trip_requestsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload>[]
        }
        create: {
          args: Prisma.trip_requestsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload>
        }
        createMany: {
          args: Prisma.trip_requestsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.trip_requestsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload>[]
        }
        delete: {
          args: Prisma.trip_requestsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload>
        }
        update: {
          args: Prisma.trip_requestsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload>
        }
        deleteMany: {
          args: Prisma.trip_requestsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.trip_requestsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.trip_requestsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload>[]
        }
        upsert: {
          args: Prisma.trip_requestsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$trip_requestsPayload>
        }
        aggregate: {
          args: Prisma.Trip_requestsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrip_requests>
        }
        groupBy: {
          args: Prisma.trip_requestsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_requestsGroupByOutputType>[]
        }
        count: {
          args: Prisma.trip_requestsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Trip_requestsCountAggregateOutputType> | number
        }
      }
    }
    user_roles: {
      payload: Prisma.$user_rolesPayload<ExtArgs>
      fields: Prisma.user_rolesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.user_rolesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.user_rolesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload>
        }
        findFirst: {
          args: Prisma.user_rolesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.user_rolesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload>
        }
        findMany: {
          args: Prisma.user_rolesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
        }
        create: {
          args: Prisma.user_rolesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload>
        }
        createMany: {
          args: Prisma.user_rolesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.user_rolesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
        }
        delete: {
          args: Prisma.user_rolesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload>
        }
        update: {
          args: Prisma.user_rolesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload>
        }
        deleteMany: {
          args: Prisma.user_rolesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.user_rolesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.user_rolesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
        }
        upsert: {
          args: Prisma.user_rolesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_rolesPayload>
        }
        aggregate: {
          args: Prisma.User_rolesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser_roles>
        }
        groupBy: {
          args: Prisma.user_rolesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.User_rolesGroupByOutputType>[]
        }
        count: {
          args: Prisma.user_rolesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.User_rolesCountAggregateOutputType> | number
        }
      }
    }
    users: {
      payload: Prisma.$usersPayload<ExtArgs>
      fields: Prisma.usersFieldRefs
      operations: {
        findUnique: {
          args: Prisma.usersFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload>
        }
        findFirst: {
          args: Prisma.usersFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload>
        }
        findMany: {
          args: Prisma.usersFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload>[]
        }
        create: {
          args: Prisma.usersCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload>
        }
        createMany: {
          args: Prisma.usersCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload>[]
        }
        delete: {
          args: Prisma.usersDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload>
        }
        update: {
          args: Prisma.usersUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload>
        }
        deleteMany: {
          args: Prisma.usersDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.usersUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload>[]
        }
        upsert: {
          args: Prisma.usersUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$usersPayload>
        }
        aggregate: {
          args: Prisma.UsersAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUsers>
        }
        groupBy: {
          args: Prisma.usersGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UsersGroupByOutputType>[]
        }
        count: {
          args: Prisma.usersCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UsersCountAggregateOutputType> | number
        }
      }
    }
    vehicle_leases: {
      payload: Prisma.$vehicle_leasesPayload<ExtArgs>
      fields: Prisma.vehicle_leasesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.vehicle_leasesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.vehicle_leasesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload>
        }
        findFirst: {
          args: Prisma.vehicle_leasesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.vehicle_leasesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload>
        }
        findMany: {
          args: Prisma.vehicle_leasesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload>[]
        }
        create: {
          args: Prisma.vehicle_leasesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload>
        }
        createMany: {
          args: Prisma.vehicle_leasesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.vehicle_leasesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload>[]
        }
        delete: {
          args: Prisma.vehicle_leasesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload>
        }
        update: {
          args: Prisma.vehicle_leasesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload>
        }
        deleteMany: {
          args: Prisma.vehicle_leasesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.vehicle_leasesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.vehicle_leasesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload>[]
        }
        upsert: {
          args: Prisma.vehicle_leasesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_leasesPayload>
        }
        aggregate: {
          args: Prisma.Vehicle_leasesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicle_leases>
        }
        groupBy: {
          args: Prisma.vehicle_leasesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Vehicle_leasesGroupByOutputType>[]
        }
        count: {
          args: Prisma.vehicle_leasesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Vehicle_leasesCountAggregateOutputType> | number
        }
      }
    }
    vehicles: {
      payload: Prisma.$vehiclesPayload<ExtArgs>
      fields: Prisma.vehiclesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.vehiclesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.vehiclesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload>
        }
        findFirst: {
          args: Prisma.vehiclesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.vehiclesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload>
        }
        findMany: {
          args: Prisma.vehiclesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
        }
        create: {
          args: Prisma.vehiclesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload>
        }
        createMany: {
          args: Prisma.vehiclesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.vehiclesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
        }
        delete: {
          args: Prisma.vehiclesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload>
        }
        update: {
          args: Prisma.vehiclesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload>
        }
        deleteMany: {
          args: Prisma.vehiclesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.vehiclesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.vehiclesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
        }
        upsert: {
          args: Prisma.vehiclesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclesPayload>
        }
        aggregate: {
          args: Prisma.VehiclesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicles>
        }
        groupBy: {
          args: Prisma.vehiclesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehiclesGroupByOutputType>[]
        }
        count: {
          args: Prisma.vehiclesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehiclesCountAggregateOutputType> | number
        }
      }
    }
    rate_limit: {
      payload: Prisma.$rate_limitPayload<ExtArgs>
      fields: Prisma.rate_limitFieldRefs
      operations: {
        findUnique: {
          args: Prisma.rate_limitFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.rate_limitFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload>
        }
        findFirst: {
          args: Prisma.rate_limitFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.rate_limitFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload>
        }
        findMany: {
          args: Prisma.rate_limitFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload>[]
        }
        create: {
          args: Prisma.rate_limitCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload>
        }
        createMany: {
          args: Prisma.rate_limitCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.rate_limitCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload>[]
        }
        delete: {
          args: Prisma.rate_limitDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload>
        }
        update: {
          args: Prisma.rate_limitUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload>
        }
        deleteMany: {
          args: Prisma.rate_limitDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.rate_limitUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.rate_limitUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload>[]
        }
        upsert: {
          args: Prisma.rate_limitUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rate_limitPayload>
        }
        aggregate: {
          args: Prisma.Rate_limitAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRate_limit>
        }
        groupBy: {
          args: Prisma.rate_limitGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Rate_limitGroupByOutputType>[]
        }
        count: {
          args: Prisma.rate_limitCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Rate_limitCountAggregateOutputType> | number
        }
      }
    }
    PasswordReset: {
      payload: Prisma.$PasswordResetPayload<ExtArgs>
      fields: Prisma.PasswordResetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        findFirst: {
          args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        findMany: {
          args: Prisma.PasswordResetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
        }
        create: {
          args: Prisma.PasswordResetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        createMany: {
          args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PasswordResetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
        }
        delete: {
          args: Prisma.PasswordResetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        update: {
          args: Prisma.PasswordResetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        deleteMany: {
          args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PasswordResetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
        }
        upsert: {
          args: Prisma.PasswordResetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        aggregate: {
          args: Prisma.PasswordResetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePasswordReset>
        }
        groupBy: {
          args: Prisma.PasswordResetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PasswordResetGroupByOutputType>[]
        }
        count: {
          args: Prisma.PasswordResetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PasswordResetCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const Agreement_rate_cardsScalarFieldEnum = {
  id: 'id',
  agreement_id: 'agreement_id',
  vehicle_type: 'vehicle_type',
  base_rate: 'base_rate',
  per_km_rate: 'per_km_rate',
  per_hour_rate: 'per_hour_rate',
  night_charges: 'night_charges',
  holiday_charges: 'holiday_charges',
  waiting_charges_per_hour: 'waiting_charges_per_hour',
  minimum_charge: 'minimum_charge',
  cancellation_charge: 'cancellation_charge',
  currency: 'currency',
  effective_from: 'effective_from',
  effective_to: 'effective_to',
  created_at: 'created_at',
  created_by: 'created_by'
} as const

export type Agreement_rate_cardsScalarFieldEnum = (typeof Agreement_rate_cardsScalarFieldEnum)[keyof typeof Agreement_rate_cardsScalarFieldEnum]


export const Audit_logsScalarFieldEnum = {
  id: 'id',
  user_id: 'user_id',
  user_name: 'user_name',
  user_email: 'user_email',
  user_role: 'user_role',
  action: 'action',
  module: 'module',
  entity_type: 'entity_type',
  entity_id: 'entity_id',
  entity_name: 'entity_name',
  old_value: 'old_value',
  new_value: 'new_value',
  changes: 'changes',
  ip_address: 'ip_address',
  user_agent: 'user_agent',
  request_method: 'request_method',
  request_url: 'request_url',
  status: 'status',
  error_message: 'error_message',
  session_id: 'session_id',
  request_id: 'request_id',
  description: 'description',
  created_at: 'created_at'
} as const

export type Audit_logsScalarFieldEnum = (typeof Audit_logsScalarFieldEnum)[keyof typeof Audit_logsScalarFieldEnum]


export const Business_unitsScalarFieldEnum = {
  id: 'id',
  name: 'name',
  code: 'code',
  description: 'description',
  head_id: 'head_id',
  status: 'status',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by',
  deleted_at: 'deleted_at'
} as const

export type Business_unitsScalarFieldEnum = (typeof Business_unitsScalarFieldEnum)[keyof typeof Business_unitsScalarFieldEnum]


export const Cab_agreementsScalarFieldEnum = {
  id: 'id',
  cab_service_id: 'cab_service_id',
  agreement_number: 'agreement_number',
  title: 'title',
  type: 'type',
  status: 'status',
  priority: 'priority',
  client_company_name: 'client_company_name',
  client_contact_person: 'client_contact_person',
  client_email: 'client_email',
  client_phone: 'client_phone',
  start_date: 'start_date',
  end_date: 'end_date',
  auto_renewal: 'auto_renewal',
  renewal_period: 'renewal_period',
  notice_period_days: 'notice_period_days',
  contract_value: 'contract_value',
  currency: 'currency',
  payment_terms: 'payment_terms',
  payment_schedule: 'payment_schedule',
  security_deposit: 'security_deposit',
  insurance_required: 'insurance_required',
  insurance_amount: 'insurance_amount',
  insurance_provider: 'insurance_provider',
  insurance_policy_number: 'insurance_policy_number',
  insurance_expiry_date: 'insurance_expiry_date',
  sla_response_time: 'sla_response_time',
  sla_availability_percentage: 'sla_availability_percentage',
  sla_on_time_performance: 'sla_on_time_performance',
  termination_clause: 'termination_clause',
  penalty_clause: 'penalty_clause',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by',
  deleted_at: 'deleted_at'
} as const

export type Cab_agreementsScalarFieldEnum = (typeof Cab_agreementsScalarFieldEnum)[keyof typeof Cab_agreementsScalarFieldEnum]


export const Cab_servicesScalarFieldEnum = {
  id: 'id',
  name: 'name',
  code: 'code',
  type: 'type',
  status: 'status',
  description: 'description',
  registration_number: 'registration_number',
  tax_id: 'tax_id',
  primary_contact_name: 'primary_contact_name',
  primary_contact_position: 'primary_contact_position',
  primary_contact_email: 'primary_contact_email',
  primary_contact_phone: 'primary_contact_phone',
  address_street: 'address_street',
  address_city: 'address_city',
  website: 'website',
  service_areas: 'service_areas',
  is_24x7: 'is_24x7',
  operating_hours_weekdays: 'operating_hours_weekdays',
  operating_hours_weekends: 'operating_hours_weekends',
  operating_hours_holidays: 'operating_hours_holidays',
  completed_trips: 'completed_trips',
  cancelled_trips: 'cancelled_trips',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by',
  deleted_at: 'deleted_at'
} as const

export type Cab_servicesScalarFieldEnum = (typeof Cab_servicesScalarFieldEnum)[keyof typeof Cab_servicesScalarFieldEnum]


export const DepartmentsScalarFieldEnum = {
  id: 'id',
  business_unit_id: 'business_unit_id',
  name: 'name',
  code: 'code',
  description: 'description',
  type: 'type',
  status: 'status',
  head_id: 'head_id',
  budget_allocated: 'budget_allocated',
  budget_utilized: 'budget_utilized',
  budget_currency: 'budget_currency',
  fiscal_year: 'fiscal_year',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by',
  deleted_at: 'deleted_at'
} as const

export type DepartmentsScalarFieldEnum = (typeof DepartmentsScalarFieldEnum)[keyof typeof DepartmentsScalarFieldEnum]


export const DocumentsScalarFieldEnum = {
  id: 'id',
  entity_type: 'entity_type',
  entity_id: 'entity_id',
  document_type: 'document_type',
  document_number: 'document_number',
  file_name: 'file_name',
  file_path: 'file_path',
  file_size: 'file_size',
  mime_type: 'mime_type',
  issue_date: 'issue_date',
  expiry_date: 'expiry_date',
  issuing_authority: 'issuing_authority',
  status: 'status',
  verification_status: 'verification_status',
  verified_by: 'verified_by',
  verified_at: 'verified_at',
  version: 'version',
  is_current: 'is_current',
  replaces_document_id: 'replaces_document_id',
  notes: 'notes',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by',
  deleted_at: 'deleted_at'
} as const

export type DocumentsScalarFieldEnum = (typeof DocumentsScalarFieldEnum)[keyof typeof DocumentsScalarFieldEnum]


export const DriversScalarFieldEnum = {
  id: 'id',
  user_id: 'user_id',
  license_number: 'license_number',
  license_type: 'license_type',
  license_issue_date: 'license_issue_date',
  license_expiry_date: 'license_expiry_date',
  license_issuing_authority: 'license_issuing_authority',
  license_state: 'license_state',
  medical_certificate_number: 'medical_certificate_number',
  medical_certificate_expiry: 'medical_certificate_expiry',
  background_check_status: 'background_check_status',
  background_check_date: 'background_check_date',
  background_check_valid_until: 'background_check_valid_until',
  driver_status: 'driver_status',
  years_of_experience: 'years_of_experience',
  previous_employer: 'previous_employer',
  training_completed: 'training_completed',
  training_completion_date: 'training_completion_date',
  training_expiry_date: 'training_expiry_date',
  total_trips_completed: 'total_trips_completed',
  total_distance_driven: 'total_distance_driven',
  violations_count: 'violations_count',
  accidents_count: 'accidents_count',
  current_vehicle_id: 'current_vehicle_id',
  assigned_to_vehicle_date: 'assigned_to_vehicle_date',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by',
  deleted_at: 'deleted_at'
} as const

export type DriversScalarFieldEnum = (typeof DriversScalarFieldEnum)[keyof typeof DriversScalarFieldEnum]


export const Email_templatesScalarFieldEnum = {
  id: 'id',
  template_code: 'template_code',
  template_name: 'template_name',
  subject: 'subject',
  body_html: 'body_html',
  body_text: 'body_text',
  category: 'category',
  variables: 'variables',
  status: 'status',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by'
} as const

export type Email_templatesScalarFieldEnum = (typeof Email_templatesScalarFieldEnum)[keyof typeof Email_templatesScalarFieldEnum]


export const Emergency_contactsScalarFieldEnum = {
  id: 'id',
  user_id: 'user_id',
  name: 'name',
  relationship: 'relationship',
  phone: 'phone',
  email: 'email',
  is_primary: 'is_primary',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type Emergency_contactsScalarFieldEnum = (typeof Emergency_contactsScalarFieldEnum)[keyof typeof Emergency_contactsScalarFieldEnum]


export const Expiry_alertsScalarFieldEnum = {
  id: 'id',
  alert_type: 'alert_type',
  entity_type: 'entity_type',
  entity_id: 'entity_id',
  entity_name: 'entity_name',
  document_id: 'document_id',
  document_name: 'document_name',
  document_number: 'document_number',
  issue_date: 'issue_date',
  expiry_date: 'expiry_date',
  days_to_expiry: 'days_to_expiry',
  status: 'status',
  priority: 'priority',
  department: 'department',
  assigned_to: 'assigned_to',
  reminders_sent: 'reminders_sent',
  last_reminder_date: 'last_reminder_date',
  renewal_process_started: 'renewal_process_started',
  renewal_documents_submitted: 'renewal_documents_submitted',
  renewal_payment_made: 'renewal_payment_made',
  new_expiry_date: 'new_expiry_date',
  renewal_reference: 'renewal_reference',
  renewal_cost: 'renewal_cost',
  renewal_vendor: 'renewal_vendor',
  notes: 'notes',
  resolved_at: 'resolved_at',
  resolved_by: 'resolved_by',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type Expiry_alertsScalarFieldEnum = (typeof Expiry_alertsScalarFieldEnum)[keyof typeof Expiry_alertsScalarFieldEnum]


export const GeofencesScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  type: 'type',
  center_latitude: 'center_latitude',
  center_longitude: 'center_longitude',
  radius_meters: 'radius_meters',
  polygon_coordinates: 'polygon_coordinates',
  status: 'status',
  alert_on_entry: 'alert_on_entry',
  alert_on_exit: 'alert_on_exit',
  alert_recipients: 'alert_recipients',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by'
} as const

export type GeofencesScalarFieldEnum = (typeof GeofencesScalarFieldEnum)[keyof typeof GeofencesScalarFieldEnum]


export const Gps_devicesScalarFieldEnum = {
  id: 'id',
  device_id: 'device_id',
  imei: 'imei',
  vehicle_id: 'vehicle_id',
  device_model: 'device_model',
  manufacturer: 'manufacturer',
  firmware_version: 'firmware_version',
  installation_date: 'installation_date',
  last_maintenance_date: 'last_maintenance_date',
  next_maintenance_date: 'next_maintenance_date',
  status: 'status',
  battery_backup_hours: 'battery_backup_hours',
  sim_number: 'sim_number',
  network_provider: 'network_provider',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by'
} as const

export type Gps_devicesScalarFieldEnum = (typeof Gps_devicesScalarFieldEnum)[keyof typeof Gps_devicesScalarFieldEnum]


export const Gps_logsScalarFieldEnum = {
  id: 'id',
  vehicle_id: 'vehicle_id',
  driver_id: 'driver_id',
  trip_assignment_id: 'trip_assignment_id',
  device_id: 'device_id',
  latitude: 'latitude',
  longitude: 'longitude',
  altitude: 'altitude',
  accuracy: 'accuracy',
  address: 'address',
  speed: 'speed',
  heading: 'heading',
  ignition_status: 'ignition_status',
  mileage: 'mileage',
  battery_level: 'battery_level',
  signal_strength: 'signal_strength',
  network_provider: 'network_provider',
  geofence_status: 'geofence_status',
  speed_limit: 'speed_limit',
  is_speed_violation: 'is_speed_violation',
  violation_count: 'violation_count',
  panic_button: 'panic_button',
  device_timestamp: 'device_timestamp',
  server_timestamp: 'server_timestamp',
  created_at: 'created_at'
} as const

export type Gps_logsScalarFieldEnum = (typeof Gps_logsScalarFieldEnum)[keyof typeof Gps_logsScalarFieldEnum]


export const HolidaysScalarFieldEnum = {
  id: 'id',
  holiday_date: 'holiday_date',
  holiday_name: 'holiday_name',
  holiday_type: 'holiday_type',
  is_working_day: 'is_working_day',
  region: 'region',
  country: 'country',
  created_at: 'created_at',
  created_by: 'created_by'
} as const

export type HolidaysScalarFieldEnum = (typeof HolidaysScalarFieldEnum)[keyof typeof HolidaysScalarFieldEnum]


export const Insurance_policiesScalarFieldEnum = {
  id: 'id',
  vehicle_id: 'vehicle_id',
  provider: 'provider',
  policy_number: 'policy_number',
  policy_type: 'policy_type',
  coverage: 'coverage',
  premium_amount: 'premium_amount',
  currency: 'currency',
  payment_frequency: 'payment_frequency',
  start_date: 'start_date',
  expiry_date: 'expiry_date',
  status: 'status',
  idv_amount: 'idv_amount',
  deductible: 'deductible',
  agent_name: 'agent_name',
  agent_contact: 'agent_contact',
  claims_filed: 'claims_filed',
  ncb_percentage: 'ncb_percentage',
  document_id: 'document_id',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by'
} as const

export type Insurance_policiesScalarFieldEnum = (typeof Insurance_policiesScalarFieldEnum)[keyof typeof Insurance_policiesScalarFieldEnum]


export const Login_historyScalarFieldEnum = {
  id: 'id',
  user_id: 'user_id',
  login_timestamp: 'login_timestamp',
  logout_timestamp: 'logout_timestamp',
  ip_address: 'ip_address',
  user_agent: 'user_agent',
  device: 'device',
  browser: 'browser',
  operating_system: 'operating_system',
  location_city: 'location_city',
  location_country: 'location_country',
  location_coordinates: 'location_coordinates',
  login_status: 'login_status',
  failure_reason: 'failure_reason',
  two_factor_used: 'two_factor_used',
  session_id: 'session_id',
  session_duration: 'session_duration',
  created_at: 'created_at'
} as const

export type Login_historyScalarFieldEnum = (typeof Login_historyScalarFieldEnum)[keyof typeof Login_historyScalarFieldEnum]


export const Maintenance_logsScalarFieldEnum = {
  id: 'id',
  vehicle_id: 'vehicle_id',
  maintenance_type: 'maintenance_type',
  category: 'category',
  priority: 'priority',
  description: 'description',
  symptoms: 'symptoms',
  root_cause: 'root_cause',
  scheduled_date: 'scheduled_date',
  actual_date: 'actual_date',
  duration_hours: 'duration_hours',
  based_on: 'based_on',
  mileage_at_maintenance: 'mileage_at_maintenance',
  service_provider_type: 'service_provider_type',
  service_provider_name: 'service_provider_name',
  service_location: 'service_location',
  service_advisor: 'service_advisor',
  labor_cost: 'labor_cost',
  parts_cost: 'parts_cost',
  other_charges: 'other_charges',
  tax_amount: 'tax_amount',
  discount: 'discount',
  total_cost: 'total_cost',
  currency: 'currency',
  payment_status: 'payment_status',
  payment_method: 'payment_method',
  invoice_number: 'invoice_number',
  invoice_date: 'invoice_date',
  status: 'status',
  completion_date: 'completion_date',
  quality_rating: 'quality_rating',
  next_maintenance_date: 'next_maintenance_date',
  next_maintenance_mileage: 'next_maintenance_mileage',
  next_maintenance_type: 'next_maintenance_type',
  notes: 'notes',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by'
} as const

export type Maintenance_logsScalarFieldEnum = (typeof Maintenance_logsScalarFieldEnum)[keyof typeof Maintenance_logsScalarFieldEnum]


export const Maintenance_partsScalarFieldEnum = {
  id: 'id',
  maintenance_log_id: 'maintenance_log_id',
  part_number: 'part_number',
  part_name: 'part_name',
  brand: 'brand',
  quantity: 'quantity',
  unit_cost: 'unit_cost',
  total_cost: 'total_cost',
  currency: 'currency',
  warranty_duration: 'warranty_duration',
  warranty_unit: 'warranty_unit',
  warranty_expiry_date: 'warranty_expiry_date',
  supplier: 'supplier',
  created_at: 'created_at'
} as const

export type Maintenance_partsScalarFieldEnum = (typeof Maintenance_partsScalarFieldEnum)[keyof typeof Maintenance_partsScalarFieldEnum]


export const NotificationsScalarFieldEnum = {
  id: 'id',
  title: 'title',
  message: 'message',
  type: 'type',
  category: 'category',
  severity: 'severity',
  recipient_user_id: 'recipient_user_id',
  recipient_role: 'recipient_role',
  is_read: 'is_read',
  read_at: 'read_at',
  sent_via_email: 'sent_via_email',
  sent_via_sms: 'sent_via_sms',
  sent_via_push: 'sent_via_push',
  entity_type: 'entity_type',
  entity_id: 'entity_id',
  action_url: 'action_url',
  action_label: 'action_label',
  expires_at: 'expires_at',
  created_at: 'created_at'
} as const

export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


export const PermissionsScalarFieldEnum = {
  id: 'id',
  name: 'name',
  code: 'code',
  module: 'module',
  action: 'action',
  resource: 'resource',
  description: 'description',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by'
} as const

export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


export const Role_permissionsScalarFieldEnum = {
  id: 'id',
  role_id: 'role_id',
  permission_id: 'permission_id',
  assigned_date: 'assigned_date',
  assigned_by: 'assigned_by',
  created_at: 'created_at'
} as const

export type Role_permissionsScalarFieldEnum = (typeof Role_permissionsScalarFieldEnum)[keyof typeof Role_permissionsScalarFieldEnum]


export const RolesScalarFieldEnum = {
  id: 'id',
  name: 'name',
  code: 'code',
  description: 'description',
  category: 'category',
  level: 'level',
  status: 'status',
  scope: 'scope',
  parent_role_id: 'parent_role_id',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by',
  deleted_at: 'deleted_at'
} as const

export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


export const RefreshTokenScalarFieldEnum = {
  id: 'id',
  token: 'token',
  userId: 'userId',
  expires_at: 'expires_at',
  created_at: 'created_at'
} as const

export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


export const System_alertsScalarFieldEnum = {
  id: 'id',
  alert_code: 'alert_code',
  alert_type: 'alert_type',
  severity: 'severity',
  source_type: 'source_type',
  source_id: 'source_id',
  source_name: 'source_name',
  title: 'title',
  description: 'description',
  latitude: 'latitude',
  longitude: 'longitude',
  location_address: 'location_address',
  status: 'status',
  acknowledged_at: 'acknowledged_at',
  acknowledged_by: 'acknowledged_by',
  resolved_at: 'resolved_at',
  resolved_by: 'resolved_by',
  resolution_notes: 'resolution_notes',
  escalated: 'escalated',
  escalated_at: 'escalated_at',
  escalated_to: 'escalated_to',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type System_alertsScalarFieldEnum = (typeof System_alertsScalarFieldEnum)[keyof typeof System_alertsScalarFieldEnum]


export const System_settingsScalarFieldEnum = {
  id: 'id',
  setting_key: 'setting_key',
  setting_value: 'setting_value',
  setting_type: 'setting_type',
  category: 'category',
  description: 'description',
  is_encrypted: 'is_encrypted',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by'
} as const

export type System_settingsScalarFieldEnum = (typeof System_settingsScalarFieldEnum)[keyof typeof System_settingsScalarFieldEnum]


export const Trip_approvalsScalarFieldEnum = {
  id: 'id',
  trip_request_id: 'trip_request_id',
  approval_level: 'approval_level',
  approver_role: 'approver_role',
  approver_user_id: 'approver_user_id',
  approver_department: 'approver_department',
  status: 'status',
  approved_at: 'approved_at',
  comments: 'comments',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type Trip_approvalsScalarFieldEnum = (typeof Trip_approvalsScalarFieldEnum)[keyof typeof Trip_approvalsScalarFieldEnum]


export const Trip_assignmentsScalarFieldEnum = {
  id: 'id',
  trip_request_id: 'trip_request_id',
  vehicle_id: 'vehicle_id',
  driver_id: 'driver_id',
  assignment_status: 'assignment_status',
  assigned_by: 'assigned_by',
  assigned_at: 'assigned_at',
  started_at: 'started_at',
  completed_at: 'completed_at',
  actual_departure_time: 'actual_departure_time',
  actual_arrival_time: 'actual_arrival_time',
  actual_distance: 'actual_distance',
  actual_duration: 'actual_duration',
  current_status: 'current_status',
  current_location_latitude: 'current_location_latitude',
  current_location_longitude: 'current_location_longitude',
  last_location_update: 'last_location_update',
  passenger_rating: 'passenger_rating',
  passenger_feedback: 'passenger_feedback',
  driver_rating: 'driver_rating',
  driver_feedback: 'driver_feedback',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type Trip_assignmentsScalarFieldEnum = (typeof Trip_assignmentsScalarFieldEnum)[keyof typeof Trip_assignmentsScalarFieldEnum]


export const Trip_costsScalarFieldEnum = {
  id: 'id',
  trip_assignment_id: 'trip_assignment_id',
  base_fare: 'base_fare',
  distance_charges: 'distance_charges',
  time_charges: 'time_charges',
  fuel_cost: 'fuel_cost',
  toll_charges: 'toll_charges',
  parking_charges: 'parking_charges',
  waiting_charges: 'waiting_charges',
  night_surcharge: 'night_surcharge',
  holiday_surcharge: 'holiday_surcharge',
  driver_allowance: 'driver_allowance',
  other_charges: 'other_charges',
  tax_percentage: 'tax_percentage',
  tax_amount: 'tax_amount',
  sub_total: 'sub_total',
  discount: 'discount',
  total_cost: 'total_cost',
  currency: 'currency',
  payment_status: 'payment_status',
  payment_method: 'payment_method',
  paid_at: 'paid_at',
  invoice_number: 'invoice_number',
  invoice_date: 'invoice_date',
  cost_breakdown_details: 'cost_breakdown_details',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by'
} as const

export type Trip_costsScalarFieldEnum = (typeof Trip_costsScalarFieldEnum)[keyof typeof Trip_costsScalarFieldEnum]


export const Trip_logsScalarFieldEnum = {
  id: 'id',
  trip_request_id: 'trip_request_id',
  trip_assignment_id: 'trip_assignment_id',
  trip_number: 'trip_number',
  trip_date: 'trip_date',
  trip_status: 'trip_status',
  passenger_name: 'passenger_name',
  passenger_department: 'passenger_department',
  driver_name: 'driver_name',
  vehicle_registration: 'vehicle_registration',
  from_location: 'from_location',
  to_location: 'to_location',
  planned_distance: 'planned_distance',
  actual_distance: 'actual_distance',
  planned_departure: 'planned_departure',
  actual_departure: 'actual_departure',
  planned_arrival: 'planned_arrival',
  actual_arrival: 'actual_arrival',
  total_duration: 'total_duration',
  on_time: 'on_time',
  total_cost: 'total_cost',
  fuel_cost: 'fuel_cost',
  toll_charges: 'toll_charges',
  parking_charges: 'parking_charges',
  other_charges: 'other_charges',
  currency: 'currency',
  overall_rating: 'overall_rating',
  punctuality_rating: 'punctuality_rating',
  driver_behavior_rating: 'driver_behavior_rating',
  vehicle_condition_rating: 'vehicle_condition_rating',
  comments: 'comments',
  created_at: 'created_at'
} as const

export type Trip_logsScalarFieldEnum = (typeof Trip_logsScalarFieldEnum)[keyof typeof Trip_logsScalarFieldEnum]


export const Trip_passengersScalarFieldEnum = {
  id: 'id',
  trip_request_id: 'trip_request_id',
  name: 'name',
  employee_id: 'employee_id',
  department: 'department',
  phone_number: 'phone_number',
  email: 'email',
  created_at: 'created_at'
} as const

export type Trip_passengersScalarFieldEnum = (typeof Trip_passengersScalarFieldEnum)[keyof typeof Trip_passengersScalarFieldEnum]


export const Trip_requestsScalarFieldEnum = {
  id: 'id',
  request_number: 'request_number',
  requested_by_user_id: 'requested_by_user_id',
  requested_for_user_id: 'requested_for_user_id',
  from_location_address: 'from_location_address',
  from_location_latitude: 'from_location_latitude',
  from_location_longitude: 'from_location_longitude',
  from_location_landmark: 'from_location_landmark',
  to_location_address: 'to_location_address',
  to_location_latitude: 'to_location_latitude',
  to_location_longitude: 'to_location_longitude',
  to_location_landmark: 'to_location_landmark',
  departure_date: 'departure_date',
  departure_time: 'departure_time',
  return_date: 'return_date',
  return_time: 'return_time',
  is_round_trip: 'is_round_trip',
  estimated_distance: 'estimated_distance',
  estimated_duration: 'estimated_duration',
  trip_type: 'trip_type',
  purpose_category: 'purpose_category',
  purpose_description: 'purpose_description',
  project_code: 'project_code',
  cost_center: 'cost_center',
  business_justification: 'business_justification',
  vehicle_type_required: 'vehicle_type_required',
  passenger_count: 'passenger_count',
  ac_required: 'ac_required',
  luggage_type: 'luggage_type',
  luggage_requirements: 'luggage_requirements',
  wheelchair_accessible: 'wheelchair_accessible',
  driver_required: 'driver_required',
  special_instructions: 'special_instructions',
  priority: 'priority',
  status: 'status',
  estimated_cost: 'estimated_cost',
  currency: 'currency',
  approval_required: 'approval_required',
  approval_level_required: 'approval_level_required',
  billing_type: 'billing_type',
  bill_to_department_id: 'bill_to_department_id',
  budget_code: 'budget_code',
  cancelled_at: 'cancelled_at',
  cancelled_by: 'cancelled_by',
  cancellation_reason: 'cancellation_reason',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type Trip_requestsScalarFieldEnum = (typeof Trip_requestsScalarFieldEnum)[keyof typeof Trip_requestsScalarFieldEnum]


export const User_rolesScalarFieldEnum = {
  id: 'id',
  user_id: 'user_id',
  role_id: 'role_id',
  assigned_date: 'assigned_date',
  assigned_by: 'assigned_by',
  status: 'status',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type User_rolesScalarFieldEnum = (typeof User_rolesScalarFieldEnum)[keyof typeof User_rolesScalarFieldEnum]


export const UsersScalarFieldEnum = {
  id: 'id',
  employee_id: 'employee_id',
  email: 'email',
  password_hash: 'password_hash',
  first_name: 'first_name',
  last_name: 'last_name',
  phone: 'phone',
  date_of_birth: 'date_of_birth',
  gender: 'gender',
  profile_picture: 'profile_picture',
  address_street: 'address_street',
  address_city: 'address_city',
  address_state: 'address_state',
  address_zip_code: 'address_zip_code',
  address_country: 'address_country',
  department_id: 'department_id',
  business_unit_id: 'business_unit_id',
  position: 'position',
  manager_id: 'manager_id',
  hire_date: 'hire_date',
  employment_type: 'employment_type',
  work_location: 'work_location',
  salary_amount: 'salary_amount',
  salary_currency: 'salary_currency',
  salary_frequency: 'salary_frequency',
  status: 'status',
  two_factor_enabled: 'two_factor_enabled',
  last_login: 'last_login',
  login_count: 'login_count',
  password_last_changed: 'password_last_changed',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by',
  deleted_at: 'deleted_at'
} as const

export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


export const Vehicle_leasesScalarFieldEnum = {
  id: 'id',
  vehicle_id: 'vehicle_id',
  lessor_name: 'lessor_name',
  lessor_contact: 'lessor_contact',
  lease_start_date: 'lease_start_date',
  lease_end_date: 'lease_end_date',
  monthly_payment: 'monthly_payment',
  total_lease_amount: 'total_lease_amount',
  currency: 'currency',
  payment_status: 'payment_status',
  next_payment_date: 'next_payment_date',
  terms_and_conditions: 'terms_and_conditions',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by'
} as const

export type Vehicle_leasesScalarFieldEnum = (typeof Vehicle_leasesScalarFieldEnum)[keyof typeof Vehicle_leasesScalarFieldEnum]


export const VehiclesScalarFieldEnum = {
  id: 'id',
  registration_number: 'registration_number',
  make: 'make',
  model: 'model',
  year: 'year',
  color: 'color',
  chassis_number: 'chassis_number',
  engine_number: 'engine_number',
  vehicle_type: 'vehicle_type',
  fuel_type: 'fuel_type',
  transmission: 'transmission',
  seating_capacity: 'seating_capacity',
  operational_status: 'operational_status',
  availability_status: 'availability_status',
  condition_status: 'condition_status',
  current_location: 'current_location',
  home_base: 'home_base',
  latitude: 'latitude',
  longitude: 'longitude',
  location_updated_at: 'location_updated_at',
  current_driver_id: 'current_driver_id',
  assigned_department_id: 'assigned_department_id',
  driver_assigned_date: 'driver_assigned_date',
  engine_displacement: 'engine_displacement',
  engine_power: 'engine_power',
  engine_torque: 'engine_torque',
  fuel_capacity: 'fuel_capacity',
  mileage_city: 'mileage_city',
  mileage_highway: 'mileage_highway',
  mileage_combined: 'mileage_combined',
  length_mm: 'length_mm',
  width_mm: 'width_mm',
  height_mm: 'height_mm',
  wheelbase_mm: 'wheelbase_mm',
  kerb_weight_kg: 'kerb_weight_kg',
  gross_weight_kg: 'gross_weight_kg',
  ownership_type: 'ownership_type',
  purchase_date: 'purchase_date',
  purchase_price: 'purchase_price',
  current_value: 'current_value',
  total_kilometers: 'total_kilometers',
  total_trips: 'total_trips',
  cab_service_id: 'cab_service_id',
  created_at: 'created_at',
  created_by: 'created_by',
  updated_at: 'updated_at',
  updated_by: 'updated_by',
  deleted_at: 'deleted_at'
} as const

export type VehiclesScalarFieldEnum = (typeof VehiclesScalarFieldEnum)[keyof typeof VehiclesScalarFieldEnum]


export const Rate_limitScalarFieldEnum = {
  id: 'id',
  key: 'key',
  points: 'points',
  expire: 'expire'
} as const

export type Rate_limitScalarFieldEnum = (typeof Rate_limitScalarFieldEnum)[keyof typeof Rate_limitScalarFieldEnum]


export const PasswordResetScalarFieldEnum = {
  id: 'id',
  email: 'email',
  token: 'token',
  expires_at: 'expires_at',
  created_at: 'created_at'
} as const

export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'BigInt[]'
 */
export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  agreement_rate_cards?: Prisma.agreement_rate_cardsOmit
  audit_logs?: Prisma.audit_logsOmit
  business_units?: Prisma.business_unitsOmit
  cab_agreements?: Prisma.cab_agreementsOmit
  cab_services?: Prisma.cab_servicesOmit
  departments?: Prisma.departmentsOmit
  documents?: Prisma.documentsOmit
  drivers?: Prisma.driversOmit
  email_templates?: Prisma.email_templatesOmit
  emergency_contacts?: Prisma.emergency_contactsOmit
  expiry_alerts?: Prisma.expiry_alertsOmit
  geofences?: Prisma.geofencesOmit
  gps_devices?: Prisma.gps_devicesOmit
  gps_logs?: Prisma.gps_logsOmit
  holidays?: Prisma.holidaysOmit
  insurance_policies?: Prisma.insurance_policiesOmit
  login_history?: Prisma.login_historyOmit
  maintenance_logs?: Prisma.maintenance_logsOmit
  maintenance_parts?: Prisma.maintenance_partsOmit
  notifications?: Prisma.notificationsOmit
  permissions?: Prisma.permissionsOmit
  role_permissions?: Prisma.role_permissionsOmit
  roles?: Prisma.rolesOmit
  refreshToken?: Prisma.RefreshTokenOmit
  system_alerts?: Prisma.system_alertsOmit
  system_settings?: Prisma.system_settingsOmit
  trip_approvals?: Prisma.trip_approvalsOmit
  trip_assignments?: Prisma.trip_assignmentsOmit
  trip_costs?: Prisma.trip_costsOmit
  trip_logs?: Prisma.trip_logsOmit
  trip_passengers?: Prisma.trip_passengersOmit
  trip_requests?: Prisma.trip_requestsOmit
  user_roles?: Prisma.user_rolesOmit
  users?: Prisma.usersOmit
  vehicle_leases?: Prisma.vehicle_leasesOmit
  vehicles?: Prisma.vehiclesOmit
  rate_limit?: Prisma.rate_limitOmit
  passwordReset?: Prisma.PasswordResetOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

